# -*- coding: utf-8 -*-
"""POD - 02/NumPy/Individual - Agostina Leonard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1401K3TYCs6IQ3WGlsZopm0y-SH9XMSN6

*   **Año:** [2024]
*   **Alumno/a:** [Agostina Leonard]
*   **Legajo:** [43663468]

# NumPy
A continuación, cada celda va a pedir algo distinto. Por favor, realizarlo con la menor cantidad de lineas posibles y con NumPy.

Importar `numpy` con el alias `np` e imprimir la versión instalada.
"""

import numpy as np
print(np.__version__)

"""Setear el "seed" de la librearia en 0."""

np.random.seed(0)

"""Crear un vector vacio (en ingles, *empty*) para subir 100 imagenes de 100x600 pixeles. Imprimir el shape de dicho vector."""

vector = np.empty((100, 100, 600))
print(vector.shape)

"""Crear dos vectores vacios donde uno tiene 1,000 elementos y el otro tiene 100,000 elementos. Imprimir el tamaño ocupado en memoria de cada arreglo en bytes."""

vec1 = np.empty(1000)
vec2 = np.empty(100000)

print(vec1.nbytes, vec2.nbytes)

"""Crear un vector vacío con 10 elementos. El quinto elemento tiene que ser igual a 1. Imprimir el vector."""

vector = np.zeros(10)
vector[4] = 1
print(vector)

"""Generar un arreglo con los valores desde 10 hasta 35 en pasos de 2. Imprimir el arreglo."""

arreglo = np.arange(10, 36, 2)
print(arreglo)

"""Generar un arreglo con los valores desde -1 hasta -1 en pasos de 0.25. Luego, revertirlo. Imprimir el arreglo."""

arreglo = np.arange(-1, 1, 0.25)[::-1]
print(arreglo)

"""Generar un arreglo que va desde -10 y 10 y que tenga 2,878 elementos. Imprimir el primer, último y 198º elemento."""

arreglo = np.linspace(-10, 10, 2878)
print(arreglo[0], arreglo[-1], arreglo[197])

"""Generar una matriz 5x5 y con valores de 0 a 24. Imprimir la matriz."""

matriz = np.arange(25).reshape(5, 5)
print(matriz)

"""Generar una lista de 10,000 elementos que vengan de una distribucion uniforme entre la constante de euler y π. (Nota: utilizar constantes de `numpy`). Dibujar la distribución con `matplotlib` en forma de histograma e imprimir el tipo de dato del arreglo."""

import matplotlib.pyplot as plt

lista = np.random.uniform(np.e, np.pi, 10000)
plt.hist(lista, bins=50)
plt.show()

print(type(lista))

"""Generar una lista de 20 elementos que vengan de una distribucion uniforme entre 0 y 1 e imprimirlo ordenado."""

lista = np.random.uniform(0, 1, 20)
lista_ordenada = np.sort(lista)
print(lista_ordenada)

"""Lo mismo que el punto anterior pero con una distribución normal con media 160 y desvío estandar 30."""

lista = np.random.normal(160, 30, 20)
lista_ordenada = np.sort(lista)
print(lista_ordenada)

"""Lo mismo que el punto anterior pero con una distribución normal con media 50 y desvío estandar 1. Imprimir el valor mas cercano (es decir, el de menor distancia) a 20 de los números generados."""

lista = np.random.normal(50, 1, 20)

valor_mas_cercano_a_20 = lista[np.abs(lista - 20).argmin()]

print("Lista generada:", lista)
print("Valor más cercano a 20:", valor_mas_cercano_a_20)

"""Teniendo en cuenta la declaración de la siguiente variable, imprimir la suma, la media, el máximo, y el mínimo de sus elementos."""

arreglo_dummy = np.array([1,9,10,23,45,78,94,78,10,23,65,47])

arreglo_dummy = np.array([1, 9, 10, 23, 45, 78, 94, 78, 10, 23, 65, 47])

suma = arreglo_dummy.sum()
media = arreglo_dummy.mean()
maximo = arreglo_dummy.max()
minimo = arreglo_dummy.min()

print("Suma:", suma)
print("Media:", media)
print("Máximo:", maximo)
print("Mínimo:", minimo)

"""Hacer lo mismo que el punto anterior pero... con un arreglo particular. Imprimir el resultado y encontrarle una explicación."""

arreglo_weird = np.array([1,9,10,23,45,78,94,np.nan,10,23,65,47])

arreglo_weird = np.array([1, 9, 10, 23, 45, 78, 94, np.nan, 10, 23, 65, 47])

suma = np.nansum(arreglo_weird)
media = np.nanmean(arreglo_weird)
maximo = np.nanmax(arreglo_weird)
minimo = np.nanmin(arreglo_weird)

print("Suma:", suma)
print("Media:", media)
print("Máximo:", maximo)
print("Mínimo:", minimo)

#Calcula todos los valores ignorando np.nan

"""Generar un conjunto de 100 numeros ***enteros*** entre 0 y 10. Imprimir la cantidad de numeros pares que se generaron e imprimir el tipo de dato del arreglo."""

conjunto = np.random.randint(0, 11, 100)
cantidad_pares = np.sum(conjunto % 2 == 0)

print("Cantidad de números pares:", cantidad_pares)
print("Tipo de dato del arreglo:", type(conjunto))

"""Generar un conjunto de 100 numeros enteros entre 0 y 10. Imprimir la cantidad de numeros mayores a 4 que se generaron."""

numeros = np.random.randint(0, 11, 100)
cantidad_mayores_a_4 = np.sum(numeros > 4)
print("Cantidad de números mayores a 4:", cantidad_mayores_a_4)

"""Generar un conjunto de 100 numeros enteros entre 0 y 10. Imprimir la cantidad de numeros mayores a 6 e impares que se generaron."""

numeros = np.random.randint(0, 11, 100)
cantidad_mayores_a_6_e_impares = np.sum((numeros > 6) & (numeros % 2 != 0))
print("Cantidad de números mayores a 6 e impares:", cantidad_mayores_a_6_e_impares)

"""Supongamos que hay elecciones nacionales en un país y la cantidad de votos fueron los siguientes:


|Candidato 1|Cantidato 2|Cantidato 3|
|--|--|--|
|1,772,322  |1,102,669|2,100,978 |

Con `numpy`, calcular el porcentaje correspondiente a cada candidato y redondear a 2 dígitos. Imprimir los porcentajes finales y el numero del candidato ganador (aunque sea obvio, responder con lógica de `numpy`).
"""

votos = np.array([1772322, 1102669, 2100978])
total_votos = np.sum(votos)
porcentajes = np.round((votos / total_votos) * 100, 2)
candidato_ganador = np.argmax(porcentajes) + 1

print("Porcentajes de votos para cada candidato:", porcentajes)
print("Candidato ganador:", candidato_ganador)

"""Generar un arreglo de 1,000 numeros de una distribución uniforme entre 0 y 1. Luego, generar otro arreglo que contenga todos los numeros del primer arreglo que son mayores a 0.7. Imprimir la media del "sub" arreglo."""

arreglo = np.random.uniform(0, 1, 1000)
sub_arreglo = arreglo[arreglo > 0.7]
media_sub_arreglo = np.mean(sub_arreglo)
print("Media del 'sub' arreglo:", media_sub_arreglo)

"""# Operación vectorizada vs. Operación loopeada
`numpy` no es solo poderoso por la gama de operaciones que podemos hacer en pocas lineas de código. Sino que por su eficiencia.

Supongamos que tenemos la función $f(x)=10*(x^2/e^x)$. Evaluar la función (en celdas apartes) entre -1 y 1 con 100,000 valores (i) con y (ii) sin un loop `for`. Medir tiempos de cada celda y sacar conclusiones.
"""

import time

def f(x):
    return 10 * (x**2 / np.exp(x))

valores = np.linspace(-1, 1, 100000)
start_time = time.time()
resultados_for = np.array([f(x) for x in valores])
end_time = time.time()

print("Tiempo con loop for:", end_time - start_time, "segundos")

def f(x):
    return 10 * (x**2 / np.exp(x))

valores = np.linspace(-1, 1, 100000)
start_time = time.time()
resultados_vectorizados = f(valores)
end_time = time.time()

print("Tiempo sin loop for:", end_time - start_time, "segundos")

"""El resultado de la celda anterior (aprovechar lo obtenido), graficarlo como gráfico de lineas."""

def f(x):
    return 10 * (x**2 / np.exp(x))

valores = np.linspace(-1, 1, 100000)
resultados = f(valores)

plt.plot(valores, resultados)
plt.title("Gráfico de líneas de f(x)")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True)
plt.show()

"""# Análisis de imagenes

Matematicamente hablando, las imagenes son arreglos. Si una imagen es de blanco y negro, tenemos una imagen de un canal y puede ser interpretado como una simple matriz (`.shape=2`). Si tiene varios canales, tenemos una matriz asignada para cada canal (`.shape=3`).

[Lenna](https://en.wikipedia.org/wiki/Lenna) es una imagen ampliamente utilizada en ciencias de la computación. Se volvió un icono. La idea va a ser analizar a la imagen y tratarla para varios propositos. Corra la siguiente celda para descargar la imagen y guardala como arreglo `numpy` en la variable `image`. Utilizar esta variable en las siguientes celdas.
"""

!wget https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png
from PIL import Image
image = Image.open('Lenna_(test_image).png')
image = np.asarray(image)

"""Arranquemos con mostrar la imagen. Para eso, utilice `matplotlib.pyplot`."""

plt.imshow(image)
plt.axis('off')
plt.title("Imagen Lenna")
plt.show()

"""¿Cual es la dimensión de la imagen y que ancho y alto tiene?"""

dimensiones = image.shape
alto = dimensiones[0]
ancho = dimensiones[1]

print("Dimensiones de la imagen:", dimensiones)
print("Ancho de la imagen:", ancho)
print("Alto de la imagen:", alto)

"""Recorte la imagen en ancho entre (tomando como referencia los ejes de la imagen vista anteriormente) los 100 y 350 pixeles y en alto entre 200 y 400 pixeles. Mostrar el resultado."""

imagen_recortada = image[200:400, 100:350]


plt.imshow(imagen_recortada)
plt.axis('off')
plt.title("Imagen recortada")
plt.show()

"""Muestre cada uno de los canales de la imagen."""

rojo = image[:, :, 0]  # Canal Rojo
verde = image[:, :, 1]  # Canal Verde
azul = image[:, :, 2]  # Canal Azul

plt.figure(figsize=(12, 4))

plt.subplot(1, 3, 1)
plt.imshow(rojo, cmap="Reds")
plt.title("Canal Rojo")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(verde, cmap="Greens")
plt.title("Canal Verde")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(azul, cmap="Blues")
plt.title("Canal Azul")
plt.axis('off')

plt.show()

"""Calcule el minimo, el máximo, y el promedio de los valores de la imagen."""

minimo = np.min(image)
maximo = np.max(image)
promedio = np.mean(image)

print("Mínimo valor de la imagen:", minimo)
print("Máximo valor de la imagen:", maximo)
print("Promedio de los valores de la imagen:", promedio)

"""La verdad que tener todos los colores de la imagen es muy redundante. Paselo a blanco y negro. Para ello, tome el promedio de los canales en cada pixel. Muestre la imagen en blanco y negro."""

imagen_bn = np.mean(image, axis=2).astype(np.uint8)

plt.imshow(imagen_bn, cmap='gray')
plt.axis('off')  # Ocultar los ejes
plt.title("Imagen en Blanco y Negro")
plt.show()

"""Por último, vamos a proceder a "binarizar" la imagen. Es decir, vamos a setear en 1 TODOS los pixeles donde la intensidad (es decir, el valor del pixel) sea mayor a 200. El resto, lo seteamos a 0. Mostrar el resultado."""

imagen_bn = np.mean(image, axis=2).astype(np.uint8)

imagen_binarizada = np.where(imagen_bn > 200, 1, 0)

plt.imshow(imagen_binarizada, cmap='gray')
plt.axis('off')
plt.title("Imagen Binarizada")
plt.show()

"""# Análisis de datos

`boston.csv` es un archivo csv ampliamente utilizado como 'juguete' en proyectos de Machine Learning. Para descargarlo, corra la siguiente celda.
"""

!wget https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/csv/MASS/Boston.csv

"""Lea el archivo csv (sin `pandas` pero se puede usar `csv`) y quedese con todas las columnas que son numericas. Inspeccionarlo puede hacer el trabajo bastante facil.

Nota: Aunque `numpy` tenga una libreria para leer archivos, en este caso no no es útil por que todas las columas constan de diferentes tipo de dato y ademas el encabezado es `string`.
"""

import csv

with open('Boston.csv', mode='r') as file:
    reader = csv.reader(file)


    encabezados = next(reader)


    filas = []
    columnas_numericas = []

    for row in reader:
        fila_numerica = []
        for i, value in enumerate(row):
            try:

                numero = float(value)
                fila_numerica.append(numero)


                if len(filas) == 0:
                    columnas_numericas.append(i)
            except ValueError:

                continue
        filas.append(fila_numerica)


    datos_numericos = np.array(filas)

print("Encabezados numéricos:", [encabezados[i] for i in columnas_numericas])

"""Una vez procesado el archivo csv, proceda a convertirlo en una matriz de `numpy`."""

with open('Boston.csv', mode='r') as file:
    reader = csv.reader(file)


    encabezados = next(reader)

    filas = []
    columnas_numericas = []

    for row in reader:
        fila_numerica = []
        for i, value in enumerate(row):
            try:

                numero = float(value)
                fila_numerica.append(numero)


                if len(filas) == 0:
                    columnas_numericas.append(i)
            except ValueError:

                continue
        filas.append(fila_numerica)


    datos_numericos = np.array(filas)

print("Encabezados numéricos:", [encabezados[i] for i in columnas_numericas])
print("Primeras 5 filas de datos numéricos:\n", datos_numericos[:5])

"""Reporte el promedio de todas las columnas."""

promedios_columnas = np.mean(datos_numericos, axis=0)

for i, promedio in enumerate(promedios_columnas):
    print(f"Promedio de la columna {i+1}: {promedio}")

"""Reporte la división entre una columna y otra (a elección cuales)"""

columna_1 = datos_numericos[:, 0]
columna_2 = datos_numericos[:, 1]


division = columna_1 / columna_2

print("Resultado de dividir la primera columna por la segunda (primeras 5 filas):")
print(division[:5])