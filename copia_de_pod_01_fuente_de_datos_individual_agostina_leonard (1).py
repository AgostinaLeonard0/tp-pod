# -*- coding: utf-8 -*-
"""Copia de POD - 01/Fuente de Datos/Individual - Agostina Leonard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H4jfYFooW9l2Xq1H0OKvaPPiQNIO6tHn

*   **Año:** [2024]
*   **Alumno/a:** [Agostina Leonard]
*   **Legajo:** [LEGAJO]

# Archivos de texto plano

[gutenberg.org](https://www.gutenberg.org/) (llamado así por el inventor de la imprenta moderna) es el sitio web del Proyecto Gutenberg que se dedica a la distribución y creación de eBooks. En este sitio se encuentra el [Don Quijote](https://www.gutenberg.org/ebooks/14859). El Don Quijote se puede leer en diferentes formatos, ¿no? Para la tarea, se va a usar el Don Quijote de texto plano. La siguiente celda descarga el .txt y lo guarda en el sistema para luego su futura lectura:
"""

!wget https://www.gutenberg.org/cache/epub/2000/pg2000.txt

"""## Consignas

***NOTA: Para estas consignas, no se puede usar modulos externos a Python***

Del archivo descargado, calcular la cantidad de lineas:
"""

# Abrir el archivo en modo lectura
with open('pg2000.txt') as file:
  # Inicializar un contador de líneas
  line_count = 0

  # Iterar sobre cada línea del archivo
  for line in file:
      # Incrementar el contador por cada línea
      line_count += 1

# Mostrar la cantidad de líneas
print(f'La cantidad de líneas en el archivo es: {line_count}')

"""Del archivo descargado, calcular la cantidad de veces que se dice:
*   'Quijote'
*   'mancha'
*   'españa'

Considerar que, por ejemplo, 'QuiJoTe' es lo mismo que 'quijote' (no *case sensitive*).
"""

palabras = ["quijote", "mancha", "españa"]
count1 = 0
count2 = 0
count3 = 0

# Read the entire file content
with open('pg2000.txt') as file:
    text = file.read().lower()  # Read and convert to lowercase

# Split the text into words- words = text.split(): Esta línea divide la cadena de texto text en una lista de palabras utilizando los espacios en blanco como delimitadores. Esto significa que todas las palabras del archivo, independientemente de la línea en la que se encuentren, se almacenan en la lista words.
words = text.split()

# Iterate through the words and count occurrences (case-insensitive)
for word in words:
    if palabras[0] in word:  # Use 'in' for case-insensitive partial match
        count1 += 1
    if palabras[1] in word:
        count2 += 1
    if palabras[2] in word:
        count3 += 1

# Print the results
print(f'La cantidad de veces que aparece "quijote" es: {count1}')
print(f'La cantidad de veces que aparece "mancha" es: {count2}')
print(f'La cantidad de veces que aparece "españa" es: {count3}')

"""¿Quien es el autor y titulo del libro? Responderlo usando las herramientas utilizadas en la celda anterior (Tip: abrir el archivo de texto y ver como son las primeras lineas)."""

with open('pg2000.txt') as file:
    for line in file:

        if 'title' in line.lower():
            titulo = line.strip().replace('Title: ', '')
        elif 'author' in line.lower():
            autor = line.strip().replace('Author: ', '')
            break


print(f'Título: {titulo}')
print(f'Autor: {autor}')

"""# Archivos .csv

*Robert* De Niro actuó en mas de 100 peliculas y Rotten Tomatoes es un sitio web en el que se pueden leer criticas y ratings a peliculas hechos por críticos y usuarios. La siguiente linea descarga un archivo .csv en el que tenemos peliculas de De Niro junto a su rating en Rotten Tomatoes:
"""

!wget https://people.sc.fsu.edu/~jburkardt/data/csv/deniro.csv

"""## Consignas

***NOTA: Apartir de aca, se pueden usar modulos externos de Python***

Sabemos que el archivo tiene en su primera linea los 'headers'. ¿Cuales son? Imprimirlos.
"""

import csv

with open('deniro.csv', newline='', encoding='utf-8') as csvfile:
    reader = csv.reader(csvfile)
    headers = next(reader) #la primera fila completa del archivo CSV, que corresponde a los encabezados.

    print("Encabezados del archivo CSV:", headers)

"""Convertir la información del archivo .csv a un diccionario."""

with open('deniro.csv', newline='', encoding='utf-8') as csvfile:
    reader = csv.DictReader(csvfile)

    data = [row for row in reader] #El primer row es solo la forma en que le decimos a Python: "en cada iteración, añade el valor de row a la lista". Lo que estamos añadiendo es simplemente el row que obtenemos en cada vuelta del bucle for row in reader.

for fila in data:
    print(fila)

"""¿Cuantas peliculas hay registradas en el archivo .csv?"""

with open('deniro.csv', newline='', encoding='utf-8') as csvfile:
    reader = csv.DictReader(csvfile)

    total_peliculas = len(data)

    print(f'El total de películas en el archivo es: {total_peliculas}')

"""Imprimir las peliculas mejor y peor rankeadas del archivo (imprimir sus respectivos rankings)"""

with open('deniro.csv', newline='', encoding='utf-8') as csvfile:
    reader = csv.DictReader(csvfile)

    data = [row for row in reader]


    peliculas_rankeadas = [(c[' "Title"'].strip(), float(c[' "Score"'].replace('%', '').strip())) for c in data]

    peliculas_rankeadas.sort(key=lambda x: x[1], reverse=True)

    n = 5

    mejores_peliculas = peliculas_rankeadas[:n]
    peores_peliculas = peliculas_rankeadas[-n:]

    print(f'Las {n} mejores películas son:')
    for pelicula, ranking in mejores_peliculas:
        print(f'- {pelicula} con un ranking de {ranking}%')

    print(f'\nLas {n} peores películas son:')
    for pelicula, ranking in peores_peliculas:
        print(f'- {pelicula} con un ranking de {ranking}%')

"""# Base de datos - Relacionales

SQLite es una biblioteca de C que provee una base de datos ligera basada en disco que no requiere un proceso de servidor separado y permite acceder a la base de datos usando una variación no estándar del lenguaje de consulta SQL. Algunas aplicaciones pueden usar SQLite para almacenamiento interno. También es posible prototipar una aplicación usando SQLite y luego transferir el código a una base de datos más grande como PostgreSQL u Oracle.

Realizamos el `import` e indicamos el archivo en el que vamos a guardar la base de datos:
"""

import sqlite3
conn = sqlite3.connect('db.db')

"""La siguiente linea de codigo agrega filas a la misma. Por favor, ejecutar la siguiente celda para la consigna:


"""

!wget https://people.sc.fsu.edu/~jburkardt/data/csv/snakes_count_10000.csv

cur = conn.cursor()
cur.execute("CREATE TABLE t (GameNumber, GameLength);")

with open('snakes_count_10000.csv','r') as csv_file:
  lines = csv_file.readlines()[1:]
  lines = [l.split(',') for l in lines]
  to_db = [(l[0].strip(), l[1].strip()) for l in lines]

cur.executemany("INSERT INTO t (GameNumber, GameLength) VALUES (?, ?);", to_db)
conn.commit()
conn.close()

"""## Consignas

¿Como luce la base de datos? Imprimirla.
"""

conn = sqlite3.connect('db.db')  # Reabrir la conexión si está cerrada
cur = conn.cursor()
for row in cur.execute("SELECT * FROM t"):
    print(row)
conn.close()  # Cierra la conexión después de imprimir

"""¿Cuantas filas hay en la base de datos?"""

conn = sqlite3.connect('db.db')  # Reabrir la conexión
cur = conn.cursor()
row_count = cur.execute("SELECT COUNT(*) FROM t").fetchone()[0]  # Contar filas
print(f"Número de filas: {row_count}")
conn.close()  # Cerrar la conexión después de usarla

"""¿Cual es el máximo `GameLength` y en qué `GameNumber` se realizó?"""

conn = sqlite3.connect('db.db')  # Reabrir la conexión si está cerrada
cur = conn.cursor()
result = cur.execute("SELECT GameNumber, MAX(GameLength) FROM t").fetchone()
print(f"GameNumber: {result[0]}, Máximo GameLength: {result[1]}")
conn.close()

"""# API Requests
Por lo general, conseguimos datos a traves de internet. Aunque el concepto de Application Programming Interface (API) es muy amplio y muy poco concreto, en el contexto de los servidores, es un conjunto de 'endpoints' que los servidores ofrecen para poder leer/procesar/escribir información en estos mismos.

[En este repositorio](https://github.com/public-apis/public-apis) van a encontrar una lista de APIs públicas (pueden elegir otras que no son de ese repositorio). Para la consigna, se recomienda usar aquellas APIs que no requieren autenticación. Si se elige una API con autenticación, por favor, adjuntar las keys o pasarl las credenciales necesarias para su futura ejecución También, pueden usar varias URLs.

## Consigna

Hacer una request GET e imprimir uno de los campos de la respuesta:
"""

import requests

url = "https://meowfacts.herokuapp.com/"
response = requests.get(url)

if response.status_code == 200:
    data = response.json()
    print("Cat Fact:", data["data"][0])
else:
    print(f"Error en la solicitud: {response.status_code}")

"""Hacer una request GET y, apartir de los campos en la respuesta, generar otro campo (por ejemplo, si la respuesta solo incluye un timestamp y una posición del registro, elaborar la velocidad del registro)"""

import requests
url = "https://meowfacts.herokuapp.com/"
response = requests.get(url)

if response.status_code == 200:
    data = response.json()
    fact = data["data"][0]
    fact_length = len(fact)

    print(f"Cat Fact: {fact}")
    print(f"Fact Length (new field): {fact_length}")
else:
    print(f"Error en la solicitud: {response.status_code}")

"""# Streaming data
Ahora vamos a hacer algo muy parecido a lo anterior, pero vamos a usar APIs que nos ofrecen datos en tiempo real. Pueden encontrar APIs de este estilo [en este repositorio](https://github.com/ColinEberhardt/awesome-public-streaming-datasets) (pueden elegir otras que no son de ese repositorio)

## Consigna

Hacer un plot con `matplotlib` de una variable de una API de datos streaming en el que el eje 'y' sea la variable y el eje 'x' el tiempo.
"""

import websocket
import json
import matplotlib.pyplot as plt
from datetime import datetime
import time

timestamps = []
rates = []

ultimo_tiempo = None

def on_message(ws, message):
    global timestamps, rates, ultimo_tiempo
    data = json.loads(message)
    if isinstance(data, list):
        for transaction in data:
            timestamp = int(transaction[0])
            rate = float(transaction[3])


            if timestamp != ultimo_tiempo:
                ultimo_tiempo = timestamp
                readable_time = datetime.utcfromtimestamp(timestamp).strftime('%H:%M:%S')
                timestamps.append(readable_time)
                rates.append(rate)


                if len(timestamps) > 50:
                    timestamps.pop(0)
                    rates.pop(0)

                print(f"Data received: Time={readable_time}, Rate={rate}")

def iniciar_websocket():
    ws = websocket.WebSocketApp(
        "wss://ws-api.coincheck.com/",
        on_message=on_message
    )
    ws.on_open = lambda ws: ws.send(json.dumps({"type": "subscribe", "channel": "btc_jpy-trades"}))
    ws.run_forever()

# Función para graficar en tiempo real
def graficar():
    plt.ion()
    fig, ax = plt.subplots()
    while True:
        if rates:
            min_len = min(len(timestamps), len(rates))
            synced_timestamps = timestamps[-min_len:]
            synced_rates = rates[-min_len:]

            ax.clear()
            ax.plot(range(len(synced_rates)), synced_rates, marker='o', label="Rate")
            ax.set_title("BTC/JPY Transaction Rate")
            ax.set_xlabel("Time")
            ax.set_ylabel("Rate (JPY)")
            ax.set_xticks(range(len(synced_timestamps)))
            ax.set_xticklabels(synced_timestamps, rotation=45)
            plt.legend()
            plt.tight_layout()
            plt.pause(1)
        time.sleep(1)

import threading
threading.Thread(target=iniciar_websocket, daemon=True).start()
graficar()